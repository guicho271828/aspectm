
* Aspectm  - aspect-oriented macroexpand hooks for common lisp

=*macroexpand-hook*= in Common Lisp is quite hard to maintain correctly,
since it is global and anyone can modify it. This library provides a set of
"acceptable" way of modifying the hook. The implementation is carefully
written to provide a correct encapsulation.

AspectM provides CLOS-like /around/, /before/, /after/ hooks for
macroexpansion, and I plan to implement useful hooks based upon this system.

#+BEGIN_SRC lisp
(enable-macroexpand-hooks)       ; enable around hooks, then
(add-around-hook 'standard-hook) ; enable standard (=before+around) hook

(defmacro force-inline (&whole form name args &body body)
  (assert (eq 'defun (car form)))
  `(declaim (inline ,name)))

(set-standard-hook 'defun 'force-inline :before)

(macroexpand
  `(defun my-+ (x y) (+ x y)))

(remove-standard-hook 'defun 'force-inline :before)

#+END_SRC

** Details

/around/ hooks are always nested, just like nesting
=*macroexpand-hook*= funtions. Notable difference is that 
every /around/ hooks MUST call the next hook by calling =(call-next-hook)=,
or it signals an compile-time error. This ensures that all hooks are called
in the right order without skipping/overriding.

# Upon this layered /around/ hooks system
Upon this system, AspectM implements a set of hooks
called /standard/ hooks, which consist of /before/ and /after/ hooks.
# A before/around hook can be associated with a macro function,
# and just like /before/ and /after/ methods in CLOS, it
A before/around hook is able to:

+ see the arguments of the macro
+ prepend/append forms to the main form returned by the macro

Thus, they are not able to modify the main expansion result.
Expected usecases are: exporting symbols, proclaim =inline=, or storing the
form as a workaround for a system that does not provide
=function-lambda-expression=.

To activate this library, run these snippets:

#+BEGIN_SRC lisp
(enable-macroexpand-hooks)       ; enable around hooks, then
(add-around-hook 'standard-hook) ; enable standard hook
#+END_SRC

Unfortunately, =load= and =compile= does *not* rebind =*macroexpand-hook*=
as they do for =*readtable*= and =*package*=. You are warned.

** Setting a Standard Hook

/before/ and /after/ hooks are regular macro-functions of two arguments
(the form and environment). The example code below automatically adds
=inline= proclaration to all =defun=-ed function.

#+BEGIN_SRC lisp

(defmacro force-inline (&whole form name args &body body)
  (assert (eq 'defun (car form)))
  `(declaim (inline ,name)))

(set-standard-hook 'defun 'force-inline :before)

#+END_SRC

** Dependencies

This library is at least tested on implementation listed below:

+ SBCL 1.2.8 on X86-64 Linux  3.13.0-46-generic (author's environment)

Also, it depends on the following libraries:

+ alexandria by  ::
    Alexandria is a collection of portable public domain utilities.

+ lisp-namespace by Masataro Asai ::
    Provides LISP-N --- extensible namespaces in Common Lisp.

* Copyright

Copyright (c) 2015 Masataro Asai (guicho2.71828@gmail.com)


* License

Licensed under the LLGPL License.



